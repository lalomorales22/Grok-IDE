<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grok IDE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #0a0a0a;
            color: #ffffff;
            overflow: hidden; /* Prevent body scrolling */
        }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #111111;
            border-bottom: 1px solid #ffffff;
        }

        .navbar-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .navbar-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: #ffffff;
        }

        .main-container {
            display: flex;
            flex: 1;
            background-color: #0a0a0a;
            color: #ffffff;
            height: calc(100vh - 80px); /* Account for navbar and status bar */
            overflow: hidden;
        }

        .sidebar {
            width: 250px;
            background-color: #111111;
            border-right: 1px solid #ffffff;
            display: flex;
            flex-direction: column;
            min-width: 200px;
            max-width: 800px;
            height: 100%;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            border-bottom: 1px solid #ffffff;
            background-color: #1a1a1a;
            font-weight: bold;
        }

        .sidebar-controls {
            padding: 0.5rem;
            border-bottom: 1px solid #ffffff;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-row {
            display: flex;
            gap: 0.5rem;
        }

        .control-button {
            flex: 1;
            padding: 0.4rem 0.6rem;
            background-color: #0a0a0a;
            border: 1px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .control-button:hover {
            background-color: #ffffff;
            color: #0a0a0a;
        }

        .control-button:disabled {
            background-color: #333333;
            border-color: #666666;
            color: #666666;
            cursor: not-allowed;
        }

        .control-button:disabled:hover {
            background-color: #333333;
            color: #666666;
        }

        .file-explorer {
            flex: 1;
            padding: 0.5rem;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ffffff #1a1a1a;
        }

        .file-explorer::-webkit-scrollbar {
            width: 8px;
        }

        .file-explorer::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .file-explorer::-webkit-scrollbar-thumb {
            background-color: #ffffff;
            border-radius: 4px;
        }

        .file-explorer::-webkit-scrollbar-thumb:hover {
            background-color: #cccccc;
        }

        .folder {
            margin-bottom: 0.25rem;
        }

        .folder-name {
            padding: 0.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #ffffff;
        }

        .folder-name:hover {
            background-color: #1a1a1a;
        }

        .folder-icon {
            margin-right: 0.5rem;
        }

        .files {
            margin-left: 1.5rem;
        }

        .file {
            padding: 0.25rem;
            padding-left: 1.5rem;
            cursor: pointer;
            color: #ffffff;
        }

        .file:hover {
            background-color: #1a1a1a;
        }

        .editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background-color: #1a1a1a;
            border-bottom: 1px solid #ffffff;
            overflow-x: auto;
        }

        .tab {
            padding: 0.5rem 1rem;
            background-color: #1a1a1a;
            border: none;
            color: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
            border-right: 1px solid #ffffff;
        }

        .tab.active {
            background-color: #0a0a0a;
        }

        .tab:hover {
            background-color: #333333;
        }

        .tab.modified::after {
            content: '‚óè';
            color: #ffffff;
        }

        .editor-content {
            flex: 1;
            padding: 1rem;
            height: 100%;
            overflow: hidden;
        }

        #editor {
            width: 100%;
            height: 100%;
            background-color: #0a0a0a;
            color: #ffffff;
            border: 1px solid #ffffff;
            resize: none;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 0.5rem;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ffffff #1a1a1a;
        }

        #editor::-webkit-scrollbar {
            width: 8px;
        }

        #editor::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        #editor::-webkit-scrollbar-thumb {
            background-color: #ffffff;
            border-radius: 4px;
        }

        #editor::-webkit-scrollbar-thumb:hover {
            background-color: #cccccc;
        }

        #editor:focus {
            outline: none;
            border-color: #ffffff;
        }

        #editor:disabled {
            background-color: #111111;
            color: #40e0d0;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loading {
            padding: 1rem;
            color: #40e0d0;
            text-align: center;
        }

        .welcome-message {
            text-align: center;
            padding: 2rem;
            color: #40e0d0;
        }

        .ai-column {
            width: 350px;
            background-color: #111111;
            border-left: 1px solid #ffffff;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            min-width: 200px;
            max-width: 800px;
        }

        .ai-header {
            padding: 0.5rem 1rem;
            background-color: #1a1a1a;
            border-bottom: 1px solid #ffffff;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .ai-actions-bar {
            padding: 0.5rem;
            background-color: #0a0a0a;
            border-bottom: 1px solid #ffffff;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            align-items: center;
            flex-shrink: 0;
        }

        .ai-action-btn {
            padding: 0.3rem 0.6rem;
            background-color: #111111;
            border: 1px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.2s ease;
        }

        .ai-action-btn:hover {
            background-color: #ffffff;
            color: #0a0a0a;
        }

        .ai-action-btn.history {
            background-color: #40e0d0;
            color: #0a0a0a;
        }

        .ai-action-btn.history:hover {
            background-color: #ffffff;
            color: #40e0d0;
        }

        .ai-action-btn.clear {
            background-color: #ff4444;
            color: #ffffff;
        }

        .ai-action-btn.clear:hover {
            background-color: #ffffff;
            color: #ff4444;
        }

        .ai-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            scrollbar-width: thin;
            scrollbar-color: #ffffff #1a1a1a;
            height: 0; /* Force flex item to respect parent height */
        }

        .ai-input-area {
            padding: 0.5rem;
            background-color: #1a1a1a;
            border-top: 1px solid #ffffff;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            flex-shrink: 0; /* Prevent input area from shrinking */
        }

        .ai-input-controls {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }

        .image-upload-btn {
            padding: 0.5rem;
            background-color: #0a0a0a;
            border: 1px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
        }

        .image-upload-btn:hover {
            background-color: #ffffff;
            color: #0a0a0a;
        }

        .image-preview {
            max-width: 100%;
            max-height: 100px;
            border: 1px solid #ffffff;
            margin: 0.5rem 0;
        }

        .ai-input-area textarea {
            flex: 1;
            background-color: #0a0a0a;
            color: #ffffff;
            border: 1px solid #ffffff;
            padding: 0.5rem;
            resize: none;
            font-family: 'Consolas', 'Courier New', monospace;
            min-height: 60px;
            max-height: 120px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ffffff #1a1a1a;
        }

        .ai-input-area textarea::-webkit-scrollbar {
            width: 8px;
        }

        .ai-input-area textarea::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .ai-input-area textarea::-webkit-scrollbar-thumb {
            background-color: #ffffff;
            border-radius: 4px;
        }

        .ai-input-area textarea::-webkit-scrollbar-thumb:hover {
            background-color: #cccccc;
        }

        .ai-input-area textarea:focus {
            outline: none;
            border-color: #ffffff;
        }

        .ai-send-btn {
            padding: 0.5rem 1rem;
            background-color: #0a0a0a;
            border: 1px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-weight: bold;
            min-width: 60px;
        }

        .ai-send-btn:hover {
            background-color: #ffffff;
            color: #0a0a0a;
        }

        .ai-send-btn:disabled {
            background-color: #333333;
            border-color: #666666;
            color: #666666;
            cursor: not-allowed;
        }

        .ai-message {
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
        }

        .ai-message pre {
            position: relative;
            background: #0a0a0a;
            padding: 1rem;
            border-radius: 4px;
            margin: 0.5rem 0;
            border: 1px solid #ffffff;
        }

        .ai-message code {
            font-family: 'Consolas', 'Courier New', monospace;
            white-space: pre-wrap;
        }

        .code-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .code-action-btn {
            padding: 0.25rem 0.5rem;
            background: #1a1a1a;
            border: 1px solid #ffffff;
            color: #ffffff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.8;
        }

        .code-action-btn:hover {
            opacity: 1;
            background: #ffffff;
            color: #0a0a0a;
        }

        .smart-insert-btn {
            background: #40e0d0 !important;
            color: #0a0a0a !important;
            font-weight: bold;
        }

        .smart-insert-btn:hover {
            background: #ffffff !important;
            color: #40e0d0 !important;
        }

        .smart-insert-btn:disabled {
            background: #666666 !important;
            color: #999999 !important;
        }

        /* Code insertion preview overlay */
        .insertion-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 2px solid #40e0d0;
            border-radius: 8px;
            padding: 1.5rem;
            z-index: 10001;
            max-width: 600px;
            max-height: 400px;
            overflow: auto;
            font-family: 'Consolas', 'Courier New', monospace;
            color: #ffffff;
        }

        .insertion-preview-header {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #40e0d0;
        }

        .insertion-preview-content {
            background: #0a0a0a;
            border: 1px solid #ffffff;
            padding: 1rem;
            border-radius: 4px;
            white-space: pre-wrap;
            font-size: 13px;
            line-height: 1.4;
        }

        .insertion-preview-actions {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .preview-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-family: 'Consolas', 'Courier New', monospace;
            font-weight: bold;
            font-size: 12px;
        }

        .preview-btn.confirm {
            background: #40e0d0;
            color: #0a0a0a;
        }

        .preview-btn.confirm:hover {
            background: #ffffff;
            color: #40e0d0;
        }

        .preview-btn.cancel {
            background: #0a0a0a;
        }

        .preview-btn.cancel:hover {
            background: #ffffff;
            color: #0a0a0a;
        }

        /* Typing indicator animation */
        .typing-indicator {
            color: #40e0d0;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Terminal Footer Styles */
        .terminal-footer {
            position: fixed;
            bottom: -300px;
            left: 0;
            right: 0;
            height: 300px;
            background-color: #000000;
            border-top: 2px solid #40e0d0;
            z-index: 1000;
            transition: bottom 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .terminal-footer.open {
            bottom: 0;
        }

        .terminal-header {
            padding: 0.5rem 1rem;
            background-color: #1a1a1a;
            border-bottom: 1px solid #40e0d0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.9rem;
            color: #40e0d0;
            font-weight: bold;
        }

        .terminal-content {
            flex: 1;
            padding: 0.5rem;
            overflow-y: auto;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            color: #00ff00;
            background-color: #000000;
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
            margin-top: 0.5rem;
        }

        .terminal-prompt {
            color: #40e0d0;
            margin-right: 0.5rem;
            flex-shrink: 0;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            outline: none;
        }

        .terminal-status-btn {
            padding: 0.2rem 0.6rem;
            background-color: #000000;
            border: 1px solid #40e0d0;
            color: #40e0d0;
            cursor: pointer;
            font-family: 'Consolas', 'Courier New', monospace;
            font-weight: bold;
            font-size: 0.7rem;
            text-transform: uppercase;
            transition: all 0.2s ease;
            margin-left: 1rem;
        }

        .terminal-status-btn:hover {
            background-color: #40e0d0;
            color: #000000;
        }

        .terminal-status-btn.active {
            background-color: #40e0d0;
            color: #000000;
        }

        .terminal-output {
            white-space: pre-wrap;
            margin-bottom: 0.25rem;
        }

        .terminal-error {
            color: #ff4444;
        }

        .terminal-success {
            color: #00ff00;
        }

        .terminal-info {
            color: #40e0d0;
        }

        .resize-handle {
            width: 4px;
            background-color: #ffffff;
            cursor: col-resize;
            transition: background-color 0.2s;
        }

        .resize-handle:hover, .resize-handle.active {
            background-color: #cccccc;
        }

        .context-menu {
            position: fixed;
            background: #1a1a1a;
            border: 1px solid #ffffff;
            border-radius: 3px;
            padding: 4px 0;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(255,255,255,0.3);
        }

        .context-menu-item {
            padding: 6px 12px;
            cursor: pointer;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #333333;
        }

        .context-menu-separator {
            height: 1px;
            background: #ffffff;
            margin: 4px 0;
        }

        .new-item-input {
            position: relative;
            padding: 2px 4px;
            background: #0a0a0a;
            border: 1px solid #ffffff;
        }

        .new-item-input input {
            width: 100%;
            background: transparent;
            border: none;
            color: #ffffff;
            font-size: 13px;
            outline: none;
            padding: 2px;
        }

        .status-bar {
            background-color: #111111;
            border-top: 1px solid #ffffff;
            padding: 0.25rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #40e0d0;
        }

        .status-left {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .status-right {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-connected {
            background-color: #00ff00;
        }

        .status-disconnected {
            background-color: #ff0000;
        }

        .hidden {
            display: none !important;
        }

        .image-attachment {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background-color: #0a0a0a;
            border: 1px solid #ffffff;
            margin: 0.5rem 0;
        }

        .image-attachment img {
            max-width: 60px;
            max-height: 60px;
            border: 1px solid #ffffff;
        }

        .image-attachment-info {
            flex: 1;
            font-size: 0.8rem;
        }

        .image-attachment-remove {
            padding: 0.2rem 0.4rem;
            background-color: #ff0000;
            border: 1px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.7rem;
        }

        .image-attachment-remove:hover {
            background-color: #ffffff;
            color: #ff0000;
        }

        /* Custom Notification System */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .notification {
            background: #111111;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 1rem 1.5rem;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            min-width: 300px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            position: relative;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.success {
            border-color: #00ff00;
            background: linear-gradient(90deg, #111111 0%, #002200 100%);
        }

        .notification.error {
            border-color: #ff0000;
            background: linear-gradient(90deg, #111111 0%, #220000 100%);
        }

        .notification.info {
            border-color: #40e0d0;
            background: linear-gradient(90deg, #111111 0%, #002222 100%);
        }

        /* Chat History Styles */
        .chat-history-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #111111;
            border-left: 1px solid #ffffff;
            z-index: 9999;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .chat-history-panel.open {
            right: 0;
        }

        .chat-history-header {
            padding: 1rem;
            background: #1a1a1a;
            border-bottom: 1px solid #ffffff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .chat-history-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .chat-history-item {
            background: #0a0a0a;
            border: 1px solid #ffffff;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .chat-history-item:hover {
            background: #1a1a1a;
        }

        .chat-history-item-header {
            padding: 0.5rem;
            border-bottom: 1px solid #ffffff;
            font-size: 12px;
            color: #40e0d0;
        }

        .chat-history-item-preview {
            padding: 0.5rem;
            font-size: 13px;
            max-height: 60px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .history-toggle-btn {
            padding: 0.2rem 0.4rem;
            background-color: #0a0a0a;
            border: 1px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .history-toggle-btn:hover {
            background-color: #ffffff;
            color: #0a0a0a;
        }
    </style>
</head>
<body>
    <div class="navbar">
        <div class="navbar-left">
            <div class="navbar-title">‚ó§ GROK IDE ‚ó•</div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                EXPLORER
            </div>
            <div class="sidebar-controls">
                <div class="control-row">
                    <button id="openFolderBtn" class="control-button">OPEN FOLDER</button>
                    <button id="saveBtn" class="control-button" onclick="saveCurrentFile()" disabled>SAVE</button>
                </div>
                <div class="control-row">
                    <button id="newFolderBtn" class="control-button" onclick="createNewFolder()" disabled>NEW FOLDER</button>
                    <button id="newFileBtn" class="control-button" onclick="createNewFile()" disabled>NEW FILE</button>
                </div>
            </div>
            <div id="fileExplorer" class="file-explorer">
                <div class="welcome-message">
                    EDITOR READY - LOAD FILES TO BEGIN OPERATIONS
                </div>
            </div>
        </div>
        <div class="resize-handle" id="leftResizeHandle"></div>

        <div class="editor">
            <div id="tabs" class="tabs"></div>
            <div class="editor-content">
                <textarea id="editor" disabled placeholder="EDITOR READY - LOAD FILES TO BEGIN OPERATIONS"></textarea>
            </div>
        </div>

        <div class="resize-handle" id="rightResizeHandle"></div>
        <div class="ai-column">
            <div class="ai-header">
                GROK ASSISTANT
            </div>
            <div class="ai-actions-bar">
                <button onclick="toggleChatHistory()" class="ai-action-btn history">HISTORY</button>
                <button id="clearAIBtn" onclick="clearAIChat()" class="ai-action-btn clear">CLEAR</button>
            </div>
            <div id="aiContent" class="ai-content"></div>
            <div class="ai-input-area">
                <div id="imageAttachments"></div>
                <div class="ai-input-controls">
                    <input type="file" id="imageUpload" accept="image/*" class="hidden" onchange="handleImageUpload(event)">
                    <textarea 
                        id="aiPrompt" 
                        placeholder="Ask about your code or upload an image..."
                        rows="3"
                    ></textarea>
                    <button onclick="document.getElementById('imageUpload').click()" class="image-upload-btn">üì∑</button>
                    <button onclick="sendPrompt()" class="ai-send-btn" id="sendBtn">SEND</button>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-left">
            <span id="aiStatus">
                <span class="status-indicator status-disconnected"></span>
                AI: DISCONNECTED
            </span>
            <span id="folderStatus">FOLDER: NO FOLDER OPENED</span>
        </div>
        <div class="status-right">
            <span id="fileCount">FILES: 0</span>
            <span id="openCount">OPEN: 0</span>
            <span id="modifiedCount">MODIFIED: 0</span>
            <button class="terminal-status-btn" id="terminalStatusBtn" onclick="toggleTerminal()">TERMINAL</button>
        </div>
    </div>

    <!-- Terminal Footer -->
    <div class="terminal-footer" id="terminalFooter">
        <div class="terminal-header">
            INTEGRATED TERMINAL
            <button onclick="toggleTerminal()" style="background: none; border: none; color: #40e0d0; cursor: pointer; font-size: 16px;">‚úï</button>
        </div>
        <div class="terminal-content" id="terminalContent">
            <div class="terminal-output terminal-info">Grok IDE Terminal v1.0</div>
            <div class="terminal-output terminal-info">Type 'help' for available commands</div>
        </div>
        <div class="terminal-input-line">
            <span class="terminal-prompt" id="terminalPrompt">grok-ide:~$ </span>
            <input type="text" class="terminal-input" id="terminalInput" placeholder="Enter command..." autocomplete="off">
        </div>
    </div>



    <div class="notification-container" id="notificationContainer"></div>

    <div class="chat-history-panel" id="chatHistoryPanel">
        <div class="chat-history-header">
            CHAT HISTORY
            <button class="history-toggle-btn" onclick="toggleChatHistory()">‚úï</button>
        </div>
        <div class="chat-history-content" id="chatHistoryContent">
            <div class="loading">Loading chat history...</div>
        </div>
    </div>

    <script>
        let currentPath = '';
        const openFiles = new Map();
        let currentDirectoryHandle = null;
        let attachedImages = [];

        // Initialize UI elements
        const saveBtn = document.getElementById('saveBtn');
        const openFolderBtn = document.getElementById('openFolderBtn');
        const newFolderBtn = document.getElementById('newFolderBtn');
        const newFileBtn = document.getElementById('newFileBtn');
        const editor = document.getElementById('editor');

        // Status tracking
        let totalFileCount = 0;
        let modifiedFiles = new Set();

        async function initializeFileExplorer() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    showError('This browser does not support the File System API');
                    return;
                }
                const handle = await window.showDirectoryPicker();
                currentDirectoryHandle = handle;
                currentPath = handle.name;
                await loadFileStructure(handle);
                
                // Enable UI elements
                saveBtn.disabled = false;
                newFolderBtn.disabled = false;
                newFileBtn.disabled = false;
                editor.disabled = false;
                editor.placeholder = '';
                
                updateStatusBar();
                
                // Test AI connection
                testAIConnection();
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showError('Failed to open folder: ' + error.message);
                }
            }
        }

        async function testAIConnection() {
            try {
                const response = await fetch('/api/health');
                const data = await response.json();
                
                const aiStatus = document.getElementById('aiStatus');
                const indicator = aiStatus.querySelector('.status-indicator');
                
                if (data.features.aiCompletion) {
                    indicator.className = 'status-indicator status-connected';
                    aiStatus.innerHTML = '<span class="status-indicator status-connected"></span>AI: CONNECTED';
                } else {
                    indicator.className = 'status-indicator status-disconnected';
                    aiStatus.innerHTML = '<span class="status-indicator status-disconnected"></span>AI: DISCONNECTED';
                }
            } catch (error) {
                console.error('AI connection test failed:', error);
            }
        }

        async function loadFileStructure(directoryHandle) {
            try {
                const fileExplorer = document.getElementById('fileExplorer');
                fileExplorer.innerHTML = '<div class="loading">LOADING...</div>';
                const files = await listFiles(directoryHandle);
                renderFileStructure(files);
                updateStatusBar();
            } catch (error) {
                showError('Error loading file structure: ' + error.message);
            }
        }

        async function listFiles(directoryHandle) {
            const files = [];
            totalFileCount = 0;
            
            async function processDirectory(handle) {
                const items = [];
                for await (const entry of handle.values()) {
                    if (entry.kind === 'directory') {
                        const children = await processDirectory(entry);
                        items.push({
                            type: 'directory',
                            name: entry.name,
                            handle: entry,
                            children: children
                        });
                    } else if (entry.kind === 'file') {
                        totalFileCount++;
                        items.push({ 
                            type: 'file', 
                            name: entry.name,
                            handle: entry 
                        });
                    }
                }
                return items.sort((a, b) => {
                    if (a.type === b.type) return a.name.localeCompare(b.name);
                    return a.type === 'directory' ? -1 : 1;
                });
            }
            
            return await processDirectory(directoryHandle);
        }

        function renderFileStructure(files, parentElement = document.getElementById('fileExplorer'), parentHandle = currentDirectoryHandle) {
            parentElement.innerHTML = '';
            
            parentElement.oncontextmenu = (e) => showContextMenu(e, parentHandle);
            
            files.forEach(item => {
                if (item.type === 'directory') {
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'folder';
                    
                    const folderName = document.createElement('div');
                    folderName.className = 'folder-name';
                    folderName.innerHTML = `<span class="folder-icon">üìÅ</span>${item.name}`;
                    
                    const filesDiv = document.createElement('div');
                    filesDiv.className = 'files';
                    filesDiv.style.display = 'none';
                    
                    folderName.oncontextmenu = (e) => {
                        e.stopPropagation();
                        showContextMenu(e, item.handle);
                    };
                    
                    folderName.onclick = () => {
                        filesDiv.style.display = filesDiv.style.display === 'none' ? 'block' : 'none';
                    };
                    
                    if (item.children && item.children.length > 0) {
                        renderFileStructure(item.children, filesDiv, item.handle);
                    }
                    
                    folderDiv.appendChild(folderName);
                    folderDiv.appendChild(filesDiv);
                    parentElement.appendChild(folderDiv);
                } else {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file';
                    fileDiv.textContent = item.name;
                    fileDiv.onclick = () => openFile(item.name, item.handle);
                    parentElement.appendChild(fileDiv);
                }
            });
        }

        async function openFile(fileName, fileHandle) {
            try {
                const file = await fileHandle.getFile();
                const content = await file.text();
                openFiles.set(fileName, { content, handle: fileHandle, modified: false });
                createOrActivateTab(fileName);
                document.getElementById('editor').value = content;
                updateStatusBar();
            } catch (error) {
                showError('Error opening file: ' + error.message);
            }
        }

        function createOrActivateTab(fileName) {
            const tabs = document.getElementById('tabs');
            let tab = document.querySelector(`.tab[data-filename="${fileName}"]`);
            
            if (!tab) {
                tab = document.createElement('div');
                tab.className = 'tab';
                tab.setAttribute('data-filename', fileName);
                tab.innerHTML = `
                    ${fileName}
                    <span onclick="closeTab('${fileName}')" style="margin-left: 8px;">√ó</span>
                `;
                tabs.appendChild(tab);
            }
            
            activateTab(fileName);
        }

        function activateTab(fileName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const tab = document.querySelector(`.tab[data-filename="${fileName}"]`);
            if (tab) {
                tab.classList.add('active');
                const fileData = openFiles.get(fileName);
                if (fileData) {
                    document.getElementById('editor').value = fileData.content;
                }
            }
        }

        function closeTab(fileName) {
            const tab = document.querySelector(`.tab[data-filename="${fileName}"]`);
            if (tab) {
                if (tab.classList.contains('active')) {
                    const nextTab = tab.nextElementSibling || tab.previousElementSibling;
                    if (nextTab) {
                        activateTab(nextTab.getAttribute('data-filename'));
                    } else {
                        document.getElementById('editor').value = '';
                    }
                }
                tab.remove();
                openFiles.delete(fileName);
                modifiedFiles.delete(fileName);
                updateStatusBar();
            }
        }

        async function saveCurrentFile() {
            const activeTab = document.querySelector('.tab.active');
            if (!activeTab) {
                alert('No file is currently open');
                return;
            }
            
            try {
                const fileName = activeTab.getAttribute('data-filename');
                const fileData = openFiles.get(fileName);
                if (!fileData || !fileData.handle) {
                    throw new Error('File handle not found');
                }
                
                const content = document.getElementById('editor').value;
                const writable = await fileData.handle.createWritable();
                await writable.write(content);
                await writable.close();
                
                openFiles.set(fileName, { 
                    content: content, 
                    handle: fileData.handle,
                    modified: false
                });
                
                modifiedFiles.delete(fileName);
                activeTab.classList.remove('modified');
                updateStatusBar();
                
                showSuccess(`File ${fileName} saved successfully!`);
            } catch (error) {
                showError('Error saving file: ' + error.message);
            }
        }

        // Track editor changes
        document.getElementById('editor').addEventListener('input', () => {
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
                const fileName = activeTab.getAttribute('data-filename');
                const fileData = openFiles.get(fileName);
                if (fileData) {
                    const currentContent = document.getElementById('editor').value;
                    const isModified = currentContent !== fileData.content;
                    
                    if (isModified) {
                        modifiedFiles.add(fileName);
                        activeTab.classList.add('modified');
                    } else {
                        modifiedFiles.delete(fileName);
                        activeTab.classList.remove('modified');
                    }
                    
                    openFiles.set(fileName, {
                        ...fileData,
                        modified: isModified
                    });
                    
                    updateStatusBar();
                }
            }
        });

        function updateStatusBar() {
            document.getElementById('folderStatus').textContent = 
                currentPath ? `FOLDER: ${currentPath.toUpperCase()}` : 'FOLDER: NO FOLDER OPENED';
            document.getElementById('fileCount').textContent = `FILES: ${totalFileCount}`;
            document.getElementById('openCount').textContent = `OPEN: ${openFiles.size}`;
            document.getElementById('modifiedCount').textContent = `MODIFIED: ${modifiedFiles.size}`;
        }

        // Custom notification system
        function showNotification(message, type = 'info', duration = 500) {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            container.appendChild(notification);
            
            // Trigger animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Remove notification after duration
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }

        function showError(message) {
            console.error('[IDE ERROR]', message);
            showNotification(`[ERROR] ${message}`, 'error', 2000);
        }

        function showSuccess(message) {
            console.log('[IDE SUCCESS]', message);
            showNotification(`[SUCCESS] ${message}`, 'success', 500);
        }

        function showInfo(message) {
            console.log('[IDE INFO]', message);
            showNotification(`[INFO] ${message}`, 'info', 1000);
        }

        function refreshFileExplorer() {
            if (currentDirectoryHandle) {
                loadFileStructure(currentDirectoryHandle);
            }
        }

        // Image upload handling
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file size (max 10MB to prevent API issues)
            if (file.size > 10 * 1024 * 1024) {
                showError('Image file too large. Please use an image smaller than 10MB.');
                return;
            }

            // Validate file type
            if (!file.type.startsWith('image/')) {
                showError('Please select a valid image file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = {
                    file: file,
                    dataUrl: e.target.result,
                    name: file.name,
                    size: file.size
                };
                
                attachedImages.push(imageData);
                displayImageAttachment(imageData);
            };
            reader.onerror = function() {
                showError('Failed to read image file.');
            };
            reader.readAsDataURL(file);
        }

        function displayImageAttachment(imageData) {
            const attachmentsContainer = document.getElementById('imageAttachments');
            
            const attachmentDiv = document.createElement('div');
            attachmentDiv.className = 'image-attachment';
            attachmentDiv.innerHTML = `
                <img src="${imageData.dataUrl}" alt="${imageData.name}">
                <div class="image-attachment-info">
                    <div>${imageData.name}</div>
                    <div>${(imageData.size / 1024).toFixed(1)} KB</div>
                </div>
                <button class="image-attachment-remove" onclick="removeImageAttachment(${attachedImages.length - 1})">√ó</button>
            `;
            
            attachmentsContainer.appendChild(attachmentDiv);
        }

        function removeImageAttachment(index) {
            attachedImages.splice(index, 1);
            const attachmentsContainer = document.getElementById('imageAttachments');
            attachmentsContainer.innerHTML = '';
            
            // Re-render all attachments with updated indices
            attachedImages.forEach((imageData, i) => {
                const attachmentDiv = document.createElement('div');
                attachmentDiv.className = 'image-attachment';
                attachmentDiv.innerHTML = `
                    <img src="${imageData.dataUrl}" alt="${imageData.name}">
                    <div class="image-attachment-info">
                        <div>${imageData.name}</div>
                        <div>${(imageData.size / 1024).toFixed(1)} KB</div>
                    </div>
                    <button class="image-attachment-remove" onclick="removeImageAttachment(${i})">√ó</button>
                `;
                attachmentsContainer.appendChild(attachmentDiv);
            });
        }

        function formatMarkdown(text) {
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            
            return text.replace(codeBlockRegex, (match, language, code) => {
                const langClass = language ? ` class="language-${language}"` : '';
                return `<pre><div class="code-actions">
                    <button class="code-action-btn" onclick="copyCode(this)">COPY</button>
                    <button class="code-action-btn smart-insert-btn" onclick="insertCode(this)">SMART INSERT</button>
                    <button class="code-action-btn" onclick="simpleInsertCode(this)">INSERT</button>
                    <button class="code-action-btn" onclick="createFileFromCode(this, '${language || 'txt'}')">CREATE FILE</button>
                </div><code${langClass}>${escapeHtml(code.trim())}</code></pre>`;
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function copyCode(button) {
            const codeElement = button.closest('pre').querySelector('code');
            navigator.clipboard.writeText(codeElement.textContent)
                .then(() => {
                    const originalText = button.textContent;
                    button.textContent = 'COPIED!';
                    setTimeout(() => {
                        button.textContent = originalText;
                    }, 1500);
                })
                .catch(err => showError('Failed to copy code: ' + err.message));
        }

        async function insertCode(button) {
            const codeElement = button.closest('pre').querySelector('code');
            const codeToInsert = codeElement.textContent;
            const language = codeElement.className.replace('language-', '') || 'text';
            
            const activeTab = document.querySelector('.tab.active');
            if (!activeTab) {
                showError('No file is currently open');
                return;
            }
            
            const fileName = activeTab.getAttribute('data-filename');
            const editor = document.getElementById('editor');
            const currentContent = editor.value;
            
            try {
                // Show loading state
                const originalText = button.textContent;
                button.textContent = 'ANALYZING...';
                button.disabled = true;
                
                // Ask AI to determine the best insertion strategy
                const insertionResult = await getSmartInsertionPoint(currentContent, codeToInsert, fileName, language);
                
                if (insertionResult.success) {
                    // Show preview before applying changes
                    const confirmed = await showInsertionPreview(insertionResult, currentContent, codeToInsert);
                    
                    if (confirmed) {
                        // Apply the smart insertion
                        editor.value = insertionResult.newContent;
                        
                        // Highlight the inserted code
                        if (insertionResult.insertionStart && insertionResult.insertionEnd) {
                            editor.focus();
                            editor.setSelectionRange(insertionResult.insertionStart, insertionResult.insertionEnd);
                            
                            // Scroll to the insertion point
                            const lines = editor.value.substring(0, insertionResult.insertionStart).split('\n');
                            const lineHeight = 21; // Approximate line height
                            editor.scrollTop = (lines.length - 5) * lineHeight;
                        }
                        
                        // Mark file as modified
                        const fileData = openFiles.get(fileName);
                        if (fileData) {
                            modifiedFiles.add(fileName);
                            activeTab.classList.add('modified');
                            openFiles.set(fileName, {
                                ...fileData,
                                modified: true
                            });
                            updateStatusBar();
                        }
                        
                        showSuccess(insertionResult.message || 'Code inserted successfully');
                    } else {
                        showInfo('Smart insertion cancelled');
                    }
                } else {
                    // Fallback to cursor insertion
                    const cursorPos = editor.selectionStart;
                    const textBefore = editor.value.substring(0, cursorPos);
                    const textAfter = editor.value.substring(cursorPos);
                    
                    editor.value = textBefore + '\n' + codeToInsert + '\n' + textAfter;
                    editor.focus();
                    
                    showInfo('Code inserted at cursor position');
                }
                
            } catch (error) {
                console.error('Smart insertion failed:', error);
                showError('Smart insertion failed, using basic insertion');
                
                // Fallback insertion
                const cursorPos = editor.selectionStart;
                const textBefore = editor.value.substring(0, cursorPos);
                const textAfter = editor.value.substring(cursorPos);
                
                editor.value = textBefore + '\n' + codeToInsert + '\n' + textAfter;
                editor.focus();
                
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        function simpleInsertCode(button) {
            const codeElement = button.closest('pre').querySelector('code');
            const editor = document.getElementById('editor');
            const activeTab = document.querySelector('.tab.active');
            
            if (!activeTab) {
                showError('No file is currently open');
                return;
            }
            
            const cursorPos = editor.selectionStart;
            const textBefore = editor.value.substring(0, cursorPos);
            const textAfter = editor.value.substring(cursorPos);
            
            editor.value = textBefore + '\n' + codeElement.textContent + '\n' + textAfter;
            editor.focus();
            
            // Mark file as modified
            const fileName = activeTab.getAttribute('data-filename');
            const fileData = openFiles.get(fileName);
            if (fileData) {
                modifiedFiles.add(fileName);
                activeTab.classList.add('modified');
                openFiles.set(fileName, {
                    ...fileData,
                    modified: true
                });
                updateStatusBar();
            }
            
            showInfo('Code inserted at cursor position');
        }

        function showInsertionPreview(insertionResult, originalContent, codeToInsert) {
            return new Promise((resolve) => {
                // Create preview modal
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                const preview = document.createElement('div');
                preview.className = 'insertion-preview';
                
                // Calculate context around insertion point
                const contextLines = getInsertionContext(originalContent, insertionResult.newContent, insertionResult.insertionStart, insertionResult.insertionEnd);
                
                preview.innerHTML = `
                    <div class="insertion-preview-header">
                        Smart Insertion Preview
                    </div>
                    <div style="margin-bottom: 1rem; color: #40e0d0; font-size: 13px;">
                        Strategy: ${insertionResult.strategy || 'Smart Insert'}
                        ${insertionResult.message ? `<br>Action: ${insertionResult.message}` : ''}
                    </div>
                    <div class="insertion-preview-content">${escapeHtml(contextLines)}</div>
                    <div class="insertion-preview-actions">
                        <button class="preview-btn cancel" onclick="cancelInsertion()">CANCEL</button>
                        <button class="preview-btn confirm" onclick="confirmInsertion()">APPLY CHANGES</button>
                    </div>
                `;
                
                overlay.appendChild(preview);
                document.body.appendChild(overlay);
                
                // Global functions for button callbacks
                window.confirmInsertion = function() {
                    overlay.remove();
                    delete window.confirmInsertion;
                    delete window.cancelInsertion;
                    resolve(true);
                };
                
                window.cancelInsertion = function() {
                    overlay.remove();
                    delete window.confirmInsertion;
                    delete window.cancelInsertion;
                    resolve(false);
                };
                
                // Close on escape key
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        window.cancelInsertion();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
            });
        }

        function getInsertionContext(originalContent, newContent, insertionStart, insertionEnd) {
            try {
                // Get lines around the insertion point for context
                const newLines = newContent.split('\n');
                const originalLines = originalContent.split('\n');
                
                // Find the line numbers for the insertion
                const beforeText = newContent.substring(0, insertionStart);
                const insertedText = newContent.substring(insertionStart, insertionEnd);
                const beforeLineCount = beforeText.split('\n').length - 1;
                const insertedLineCount = insertedText.split('\n').length;
                
                // Show context: 3 lines before, the insertion, 3 lines after
                const contextStart = Math.max(0, beforeLineCount - 3);
                const contextEnd = Math.min(newLines.length, beforeLineCount + insertedLineCount + 3);
                
                let contextLines = [];
                for (let i = contextStart; i < contextEnd; i++) {
                    const lineNum = (i + 1).toString().padStart(3, ' ');
                    const isInserted = i >= beforeLineCount && i < beforeLineCount + insertedLineCount;
                    const prefix = isInserted ? '+ ' : '  ';
                    const line = newLines[i] || '';
                    contextLines.push(`${lineNum}${prefix}${line}`);
                }
                
                return contextLines.join('\n');
            } catch (error) {
                console.error('Error generating insertion context:', error);
                return `Insertion Preview:\n\n${newContent.substring(insertionStart, insertionEnd)}`;
            }
        }

        async function getSmartInsertionPoint(currentContent, codeToInsert, fileName, language) {
            try {
                const response = await fetch('/api/smart-insert', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        currentContent: currentContent,
                        codeToInsert: codeToInsert,
                        fileName: fileName,
                        language: language
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Smart insertion API failed:', error);
                return { success: false, error: error.message };
            }
        }

        async function createFileFromCode(button, language) {
            if (!currentDirectoryHandle) {
                showError('No folder is open');
                return;
            }

            const codeElement = button.closest('pre').querySelector('code');
            const code = codeElement.textContent;
            
            const extensions = {
                'javascript': 'js',
                'typescript': 'ts',
                'python': 'py',
                'html': 'html',
                'css': 'css',
                'json': 'json',
                'markdown': 'md',
                'txt': 'txt'
            };
            
            const ext = extensions[language] || 'txt';
            
            // Create a modal dialog for filename input to ensure user activation
            const fileName = await showFileNameDialog(`generated_code.${ext}`);
            
            if (fileName) {
                try {
                    const fileHandle = await currentDirectoryHandle.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(code);
                    await writable.close();
                    
                    await loadFileStructure(currentDirectoryHandle);
                    showSuccess(`File ${fileName} created successfully!`);
                } catch (error) {
                    if (error.name === 'NotAllowedError') {
                        showError('Permission denied. Please ensure you have write access to the folder.');
                    } else {
                        showError('Error creating file: ' + error.message);
                    }
                }
            }
        }

        function showFileNameDialog(defaultName) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: #111111;
                        border: 1px solid #ffffff;
                        padding: 2rem;
                        border-radius: 4px;
                        color: #ffffff;
                        font-family: 'Consolas', 'Courier New', monospace;
                    ">
                        <h3 style="margin: 0 0 1rem 0;">Create File</h3>
                        <input type="text" value="${defaultName}" style="
                            width: 300px;
                            padding: 0.5rem;
                            background: #0a0a0a;
                            border: 1px solid #ffffff;
                            color: #ffffff;
                            font-family: 'Consolas', 'Courier New', monospace;
                            margin-bottom: 1rem;
                        ">
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button style="
                                padding: 0.5rem 1rem;
                                background: #333333;
                                border: 1px solid #ffffff;
                                color: #ffffff;
                                cursor: pointer;
                            " onclick="closeModal(null)">Cancel</button>
                            <button style="
                                padding: 0.5rem 1rem;
                                background: #0a0a0a;
                                border: 1px solid #ffffff;
                                color: #ffffff;
                                cursor: pointer;
                            " onclick="closeModal(this.parentElement.parentElement.querySelector('input').value)">Create</button>
                        </div>
                    </div>
                `;
                
                window.closeModal = function(filename) {
                    modal.remove();
                    delete window.closeModal;
                    resolve(filename);
                };
                
                document.body.appendChild(modal);
                const input = modal.querySelector('input');
                input.focus();
                input.select();
                
                input.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') {
                        window.closeModal(input.value);
                    } else if (e.key === 'Escape') {
                        window.closeModal(null);
                    }
                });
            });
        }

        async function sendPrompt() {
            const prompt = document.getElementById('aiPrompt').value;
            const content = document.getElementById('editor').value;
            const aiContent = document.getElementById('aiContent');
            const sendButton = document.getElementById('sendBtn');

            if (!prompt.trim() && attachedImages.length === 0) {
                showError('Please enter a prompt or attach an image');
                return;
            }

            try {
                sendButton.disabled = true;
                sendButton.textContent = 'SENDING...';

                // Prepare messages array
                const messages = [
                    {
                        role: "system",
                        content: "You are Grok, a helpful programming assistant. When providing code examples, always wrap them in markdown code blocks with the appropriate language identifier. For example: ```javascript\ncode here\n```"
                    }
                ];

                // Handle image attachments with RAG
                if (attachedImages.length > 0) {
                    const userContent = [];
                    
                    // Add text content
                    userContent.push({
                        type: "text",
                        text: `${prompt}\n\nCode Context:\n${content}`
                    });
                    
                    // Add images
                    for (const imageData of attachedImages) {
                        userContent.push({
                            type: "image_url",
                            image_url: {
                                url: imageData.dataUrl
                            }
                        });
                    }
                    
                    messages.push({
                        role: "user",
                        content: userContent
                    });
                } else {
                    // Text-only message
                    messages.push({
                        role: "user",
                        content: `${prompt}\n\nCode Context:\n${content}`
                    });
                }

                // Create message div first for streaming
                const messageDiv = document.createElement('div');
                messageDiv.className = 'ai-message';
                
                let promptDisplay = escapeHtml(prompt);
                if (attachedImages.length > 0) {
                    promptDisplay += ` [${attachedImages.length} image(s) attached]`;
                }
                
                const responseDiv = document.createElement('div');
                responseDiv.innerHTML = '<strong>A:</strong> <span class="typing-indicator">‚óè</span>';
                
                messageDiv.innerHTML = `
                    <div><strong>Q:</strong> ${promptDisplay}</div>
                `;
                messageDiv.appendChild(responseDiv);
                messageDiv.innerHTML += `<hr style="border: none; border-top: 1px solid #ffffff; margin: 1rem 0;">`;
                
                aiContent.appendChild(messageDiv);
                aiContent.scrollTop = aiContent.scrollHeight;

                // Start streaming request
                const response = await fetch('/api/completion', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        messages: messages,
                        temperature: 0.7,
                        max_tokens: 4000,
                        stream: false // Disable streaming for now due to xAI compatibility
                    })
                });

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.message || errorData.error || errorMessage;
                        console.error('[AI ERROR] Response data:', errorData);
                    } catch (e) {
                        console.error('[AI ERROR] Failed to parse error response');
                    }
                    throw new Error(errorMessage);
                }

                // Check if this is a streaming response
                const contentType = response.headers.get('content-type');
                console.log('[AI] Response content-type:', contentType);
                
                if (contentType && contentType.includes('text/event-stream')) {
                    // Handle streaming response
                    console.log('[AI] Processing streaming response...');
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullResponse = '';
                    let buffer = '';

                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                console.log('[AI] Stream completed');
                                break;
                            }

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || ''; // Keep incomplete line in buffer

                            for (const line of lines) {
                                if (line.trim() === '') continue;
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data.trim() === '[DONE]') {
                                        // Remove typing indicator and finalize
                                        responseDiv.innerHTML = `<strong>A:</strong> ${formatMarkdown(fullResponse)}`;
                                        
                                        // Save to chat history
                                        await saveChatMessage(prompt, fullResponse, attachedImages.length > 0);
                                        return;
                                    }
                                    
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                                            fullResponse += parsed.choices[0].delta.content;
                                            responseDiv.innerHTML = `<strong>A:</strong> ${formatMarkdown(fullResponse)}<span class="typing-indicator">‚óè</span>`;
                                            aiContent.scrollTop = aiContent.scrollHeight;
                                        }
                                    } catch (e) {
                                        console.error('[AI ERROR] Failed to parse streaming chunk:', data, e);
                                    }
                                }
                            }
                        }
                        
                        // If we get here without [DONE], finalize the response
                        if (fullResponse) {
                            responseDiv.innerHTML = `<strong>A:</strong> ${formatMarkdown(fullResponse)}`;
                            await saveChatMessage(prompt, fullResponse, attachedImages.length > 0);
                        }
                    } catch (streamError) {
                        console.error('[AI ERROR] Streaming failed:', streamError);
                        throw new Error('Streaming failed: ' + streamError.message);
                    }
                } else {
                    // Handle non-streaming response (fallback)
                    console.log('[AI] Processing non-streaming response...');
                    const data = await response.json();
                    
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error('Invalid response format from AI service');
                    }

                    const aiResponse = data.choices[0].message.content;
                    responseDiv.innerHTML = `<strong>A:</strong> ${formatMarkdown(aiResponse)}`;
                    
                    // Save to chat history
                    await saveChatMessage(prompt, aiResponse, attachedImages.length > 0);
                }
                
                // Clear inputs
                document.getElementById('aiPrompt').value = '';
                attachedImages = [];
                document.getElementById('imageAttachments').innerHTML = '';
                
            } catch (error) {
                console.error('[AI ERROR] Full error:', error);
                showError('AI request failed: ' + error.message);
            } finally {
                sendButton.disabled = false;
                sendButton.textContent = 'SEND';
            }
        }

        function clearAIChat() {
            document.getElementById('aiContent').innerHTML = '';
            // Start a new chat session
            currentChatSession = {
                id: null,
                messages: []
            };
            showInfo('Started new chat session');
        }

        function initializeResizeHandles() {
            const leftHandle = document.getElementById('leftResizeHandle');
            const rightHandle = document.getElementById('rightResizeHandle');
            const sidebar = document.querySelector('.sidebar');
            const aiColumn = document.querySelector('.ai-column');

            function initializeResize(handle, element, isLeft) {
                let startX, startWidth;

                function startResize(e) {
                    startX = e.clientX;
                    startWidth = parseInt(getComputedStyle(element).width, 10);
                    handle.classList.add('active');
                    document.addEventListener('mousemove', resize);
                    document.addEventListener('mouseup', stopResize);
                    document.body.style.userSelect = 'none';
                }

                function resize(e) {
                    const diff = e.clientX - startX;
                    let newWidth = isLeft ? startWidth + diff : startWidth - diff;
                    
                    newWidth = Math.max(200, Math.min(800, newWidth));
                    element.style.width = `${newWidth}px`;
                }

                function stopResize() {
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                    document.body.style.userSelect = '';
                }

                handle.addEventListener('mousedown', startResize);
            }

            initializeResize(leftHandle, sidebar, true);
            initializeResize(rightHandle, aiColumn, false);
        }

        initializeResizeHandles();

        openFolderBtn.addEventListener('click', initializeFileExplorer);

        let contextMenu = null;
        let currentContextDirectory = null;

        function showContextMenu(e, directoryHandle) {
            e.preventDefault();
            
            removeContextMenu();
            
            currentContextDirectory = directoryHandle;
            
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.innerHTML = `
                <div class="context-menu-item" onclick="createNewFile()">
                    <span>üìÑ</span> NEW FILE
                </div>
                <div class="context-menu-item" onclick="createNewFolder()">
                    <span>üìÅ</span> NEW FOLDER
                </div>
            `;
            
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            
            document.body.appendChild(contextMenu);
            
            setTimeout(() => {
                document.addEventListener('click', removeContextMenu);
            }, 0);
        }

        function removeContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
            document.removeEventListener('click', removeContextMenu);
        }

        async function createNewFile() {
            if (!currentDirectoryHandle) {
                showError('No project folder open');
                return;
            }
            
            removeContextMenu();
            
            const filename = await showFileNameDialog('new_file.txt');
            
            if (filename) {
                try {
                    const targetDirectory = currentContextDirectory || currentDirectoryHandle;
                    const fileHandle = await targetDirectory.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write('');
                    await writable.close();
                    
                    await loadFileStructure(currentDirectoryHandle);
                    showSuccess(`File ${filename} created successfully!`);
                } catch (error) {
                    if (error.name === 'NotAllowedError') {
                        showError('Permission denied. Please ensure you have write access to the folder.');
                    } else {
                        showError('Error creating file: ' + error.message);
                    }
                }
            }
        }

        async function createNewFolder() {
            if (!currentDirectoryHandle) {
                showError('No project folder open');
                return;
            }
            
            removeContextMenu();
            
            const foldername = await showFolderNameDialog('new_folder');
            
            if (foldername) {
                try {
                    const targetDirectory = currentContextDirectory || currentDirectoryHandle;
                    await targetDirectory.getDirectoryHandle(foldername, { create: true });
                    await loadFileStructure(currentDirectoryHandle);
                    showSuccess(`Folder ${foldername} created successfully!`);
                } catch (error) {
                    if (error.name === 'NotAllowedError') {
                        showError('Permission denied. Please ensure you have write access to the folder.');
                    } else {
                        showError('Error creating folder: ' + error.message);
                    }
                }
            }
        }

        function showFolderNameDialog(defaultName) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: #111111;
                        border: 1px solid #ffffff;
                        padding: 2rem;
                        border-radius: 4px;
                        color: #ffffff;
                        font-family: 'Consolas', 'Courier New', monospace;
                    ">
                        <h3 style="margin: 0 0 1rem 0;">Create Folder</h3>
                        <input type="text" value="${defaultName}" style="
                            width: 300px;
                            padding: 0.5rem;
                            background: #0a0a0a;
                            border: 1px solid #ffffff;
                            color: #ffffff;
                            font-family: 'Consolas', 'Courier New', monospace;
                            margin-bottom: 1rem;
                        ">
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button style="
                                padding: 0.5rem 1rem;
                                background: #333333;
                                border: 1px solid #ffffff;
                                color: #ffffff;
                                cursor: pointer;
                            " onclick="closeFolderModal(null)">Cancel</button>
                            <button style="
                                padding: 0.5rem 1rem;
                                background: #0a0a0a;
                                border: 1px solid #ffffff;
                                color: #ffffff;
                                cursor: pointer;
                            " onclick="closeFolderModal(this.parentElement.parentElement.querySelector('input').value)">Create</button>
                        </div>
                    </div>
                `;
                
                window.closeFolderModal = function(foldername) {
                    modal.remove();
                    delete window.closeFolderModal;
                    resolve(foldername);
                };
                
                document.body.appendChild(modal);
                const input = modal.querySelector('input');
                input.focus();
                input.select();
                
                input.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') {
                        window.closeFolderModal(input.value);
                    } else if (e.key === 'Escape') {
                        window.closeFolderModal(null);
                    }
                });
            });
        }

        // Terminal functionality
        let terminalHistory = [];
        let historyIndex = -1;
        let currentWorkingDir = '.';

        function toggleTerminal() {
            const terminalFooter = document.getElementById('terminalFooter');
            const terminalStatusBtn = document.getElementById('terminalStatusBtn');
            
            if (terminalFooter.classList.contains('open')) {
                terminalFooter.classList.remove('open');
                terminalStatusBtn.textContent = 'TERMINAL';
                terminalStatusBtn.classList.remove('active');
            } else {
                terminalFooter.classList.add('open');
                terminalStatusBtn.textContent = 'HIDE';
                terminalStatusBtn.classList.add('active');
                // Focus on terminal input when opened
                setTimeout(() => {
                    document.getElementById('terminalInput').focus();
                }, 300);
            }
        }

        async function executeTerminalCommand(command) {
            const terminalContent = document.getElementById('terminalContent');
            const terminalPrompt = document.getElementById('terminalPrompt');
            
            // Add command to history
            if (command.trim() && terminalHistory[terminalHistory.length - 1] !== command) {
                terminalHistory.push(command);
            }
            historyIndex = terminalHistory.length;
            
            // Display the command
            const commandOutput = document.createElement('div');
            commandOutput.className = 'terminal-output';
            commandOutput.innerHTML = `<span style="color: #40e0d0;">${terminalPrompt.textContent}</span>${escapeHtml(command)}`;
            terminalContent.appendChild(commandOutput);
            
            if (!command.trim()) {
                terminalContent.scrollTop = terminalContent.scrollHeight;
                return;
            }
            
            try {
                const response = await fetch('/api/terminal', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        command: command.trim(),
                        cwd: currentWorkingDir
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Handle special actions
                    if (result.action === 'clear') {
                        // Clear terminal content except for initial messages
                        terminalContent.innerHTML = `
                            <div class="terminal-output terminal-info">Grok IDE Terminal v1.0</div>
                            <div class="terminal-output terminal-info">Type 'help' for available commands</div>
                        `;
                    } else if (result.action === 'openFile' && result.filePath) {
                        await openFileFromTerminal(result.filePath);
                    }
                    
                    if (result.output) {
                        const output = document.createElement('div');
                        output.className = 'terminal-output terminal-success';
                        output.textContent = result.output;
                        terminalContent.appendChild(output);
                    }
                    
                    // Update working directory if changed
                    if (result.cwd) {
                        currentWorkingDir = result.cwd;
                        terminalPrompt.textContent = `grok-ide:${result.cwd === '.' ? '~' : result.cwd}$ `;
                    }
                } else {
                    const errorOutput = document.createElement('div');
                    errorOutput.className = 'terminal-output terminal-error';
                    errorOutput.textContent = result.error || 'Command failed';
                    terminalContent.appendChild(errorOutput);
                }
            } catch (error) {
                const errorOutput = document.createElement('div');
                errorOutput.className = 'terminal-output terminal-error';
                errorOutput.textContent = 'Error executing command: ' + error.message;
                terminalContent.appendChild(errorOutput);
            }
            
            terminalContent.scrollTop = terminalContent.scrollHeight;
        }

        async function openFileFromTerminal(filePath) {
            try {
                if (!currentDirectoryHandle) {
                    showError('No project folder is open. Use OPEN FOLDER first.');
                    return;
                }
                
                // Navigate to the file using the file path
                const pathParts = filePath.split('/').filter(part => part && part !== '.');
                let currentHandle = currentDirectoryHandle;
                
                // Navigate through directories
                for (let i = 0; i < pathParts.length - 1; i++) {
                    currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
                }
                
                // Get the file
                const fileName = pathParts[pathParts.length - 1];
                const fileHandle = await currentHandle.getFileHandle(fileName);
                
                await openFile(fileName, fileHandle);
                showSuccess(`Opened ${filePath} from terminal`);
            } catch (error) {
                showError(`Failed to open file ${filePath}: ${error.message}`);
            }
        }

        // Terminal input handling
        document.getElementById('terminalInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const command = this.value;
                this.value = '';
                executeTerminalCommand(command);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    this.value = terminalHistory[historyIndex] || '';
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < terminalHistory.length - 1) {
                    historyIndex++;
                    this.value = terminalHistory[historyIndex] || '';
                } else {
                    historyIndex = terminalHistory.length;
                    this.value = '';
                }
            }
        });

        // Initialize status bar
        updateStatusBar();
        testAIConnection();

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveCurrentFile();
            }
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                sendPrompt();
            }
        });

        // Chat History Management
        let currentChatSession = {
            id: null,
            messages: []
        };

        function toggleChatHistory() {
            const chatHistoryPanel = document.getElementById('chatHistoryPanel');
            
            if (chatHistoryPanel.classList.contains('open')) {
                chatHistoryPanel.classList.remove('open');
            } else {
                chatHistoryPanel.classList.add('open');
                loadChatHistory();
            }
        }

        async function loadChatHistory() {
            try {
                const response = await fetch('/api/chat-history');
                const data = await response.json();
                
                const historyContent = document.getElementById('chatHistoryContent');
                
                if (data.sessions && data.sessions.length > 0) {
                    historyContent.innerHTML = data.sessions.map(session => `
                        <div class="chat-history-item" onclick="loadChatSession(${session.id})">
                            <div class="chat-history-item-header">
                                ${new Date(session.created_at).toLocaleString()}
                                <span style="float: right; color: #40e0d0;">${session.message_count} msgs</span>
                            </div>
                            <div class="chat-history-item-preview">
                                ${session.first_message || 'Empty conversation'}
                            </div>
                        </div>
                    `).join('');
                } else {
                    historyContent.innerHTML = '<div class="welcome-message">No chat history yet</div>';
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
                showError('Failed to load chat history');
            }
        }

        async function loadChatSession(sessionId) {
            try {
                const response = await fetch(`/api/chat-history/${sessionId}`);
                const data = await response.json();
                
                if (data.messages) {
                    const aiContent = document.getElementById('aiContent');
                    aiContent.innerHTML = '';
                    
                    data.messages.forEach(msg => {
                        const messageDiv = document.createElement('div');
                        messageDiv.className = 'ai-message';
                        messageDiv.innerHTML = `
                            <div><strong>Q:</strong> ${escapeHtml(msg.user_message)}</div>
                            <div><strong>A:</strong> ${formatMarkdown(msg.ai_response)}</div>
                            <hr style="border: none; border-top: 1px solid #ffffff; margin: 1rem 0;">
                        `;
                        aiContent.appendChild(messageDiv);
                    });
                    
                    aiContent.scrollTop = aiContent.scrollHeight;
                    currentChatSession.id = sessionId;
                    currentChatSession.messages = data.messages;
                    
                    toggleChatHistory(); // Close the history panel
                    showSuccess(`Loaded chat session from ${new Date(data.created_at).toLocaleString()}`);
                }
            } catch (error) {
                console.error('Failed to load chat session:', error);
                showError('Failed to load chat session');
            }
        }

        async function saveChatMessage(userMessage, aiResponse, hasImages = false) {
            try {
                const response = await fetch('/api/chat-history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        sessionId: currentChatSession.id,
                        userMessage: userMessage,
                        aiResponse: aiResponse,
                        hasImages: hasImages
                    })
                });
                
                const data = await response.json();
                if (data.sessionId) {
                    currentChatSession.id = data.sessionId;
                }
            } catch (error) {
                console.error('Failed to save chat message:', error);
                // Don't show error to user as this is background operation
            }
        }
    </script>
</body>
</html>